<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sternenhimmel mit Schaf</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; background: black; height: 100%;
  }
  canvas {
    display: block;
    touch-action: none;
  }
  #lightbox {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0,0,0,0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10;
  }
</style>
</head>
<body>
<canvas id="starCanvas"></canvas>
<div id="lightbox">
  <img src="schaf.gif" alt="Schaf Animation" style="max-width: 90vw; max-height: 90vh;"/>
</div>
<script>
(() => {
  const canvas = document.getElementById('starCanvas');
  const ctx = canvas.getContext('2d');

  let w, h;
  function resize() {
    w = window.innerWidth;
    h = window.innerHeight;
    canvas.width = w;
    canvas.height = h;
  }
  resize();
  window.addEventListener('resize', resize);

  const stars = [], bgStars = [];
  const starCount = 100, bgStarCount = 50, maxStars = 600, maxBgStars = 300;
  for(let i = 0; i < starCount; i++) {
    stars.push({ angle: Math.random() * Math.PI * 2, y: Math.random() * h, radius: 2, alpha: 0.0, targetAlpha: 0.7 });
  }
  for(let i = 0; i < bgStarCount; i++) {
    bgStars.push({ angle: Math.random() * Math.PI * 2, y: Math.random() * h, radius: 1, alpha: 0.0, targetAlpha: 0.3 });
  }

  let cameraAngle = 0, velocity = 0, zoomFactor = 1.0, zoomVelocity = 0;
  let verticalOffset = 0, verticalVelocity = 0;
  let isDragging = false, lastDragX = 0, lastDragY = 0, lastDistance = null;
  const anchorAngle = 0;

  const triggerImage = new Image();
  triggerImage.src = 'schaf-trigger.png';
  let triggerScreenX = null, triggerScreenY = null;

  function angleToScreenX(angleDiff, fov) {
    return (angleDiff + fov / 2) / fov * w;
  }

  function drawStars(starArray, fov) {
    starArray.forEach(star => {
      let diff = star.angle - cameraAngle;
      if (diff > Math.PI) diff -= 2 * Math.PI;
      if (diff < -Math.PI) diff += 2 * Math.PI;
      if (diff > -fov / 2 && diff < fov / 2) {
        const screenX = angleToScreenX(diff, fov);
        const centerY = h / 2;
        const offsetY = (star.y - centerY) * zoomFactor + verticalOffset;
        const screenY = centerY + offsetY;
        ctx.globalAlpha = star.alpha;
        ctx.beginPath();
        ctx.arc(screenX, screenY, star.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      }
    });
  }

  function updateStarsForZoom() {
    const zoomProgress = (zoomFactor - 1) / 3;
    const targetCount = Math.floor(starCount + (maxStars - starCount) * zoomProgress);
    while(stars.length < targetCount) {
      stars.push({ angle: Math.random() * Math.PI * 2, y: Math.random() * h, radius: 2, alpha: 0.0, targetAlpha: 0.7 });
    }
    for(let i = stars.length - 1; i >= targetCount; i--) {
      if (stars[i].alpha > 0) stars[i].alpha -= 0.05;
      else stars.splice(i, 1);
    }
  }

  function draw() {
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = 'white';

    const fov = (90 / zoomFactor) * Math.PI / 180;
    drawStars(bgStars, fov);
    drawStars(stars, fov);

    let diffAnchor = anchorAngle - cameraAngle;
    if (diffAnchor > Math.PI) diffAnchor -= 2 * Math.PI;
    if (diffAnchor < -Math.PI) diffAnchor += 2 * Math.PI;

    if (diffAnchor > -fov / 2 && diffAnchor < fov / 2) {
      triggerScreenX = angleToScreenX(diffAnchor, fov);
      triggerScreenY = h / 2 + verticalOffset;
      if (triggerImage.complete && triggerImage.naturalWidth !== 0) {
        ctx.drawImage(triggerImage, triggerScreenX - 20, triggerScreenY - 20, 40, 40);
      }
    } else {
      triggerScreenX = null;
      triggerScreenY = null;
    }
  }

  function animate() {
    if (!isDragging) {
      if (Math.abs(velocity) > 0.0001) { cameraAngle -= velocity; velocity *= 0.98; }
      if (Math.abs(zoomVelocity) > 0.0005) { zoomFactor += zoomVelocity; zoomVelocity *= 0.98; zoomFactor = Math.max(1, Math.min(4, zoomFactor)); }
    } else {
      verticalOffset += verticalVelocity; verticalVelocity *= 0.9;
    }
    draw();
    updateStarsForZoom();
    requestAnimationFrame(animate);
  }
  animate();

  canvas.addEventListener('click', function(e) {
    if (triggerScreenX === null || triggerScreenY === null) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    if ((x - triggerScreenX) ** 2 + (y - triggerScreenY) ** 2 < 900) {
      // Link in neuem Tab öffnen
      window.open('https://example.com', '_blank', 'noopener');
      
      // Falls du die Lightbox auch öffnen willst, kannst du die Zeile hier aktivieren:
      // document.getElementById('lightbox').style.display = 'flex';
    }
  });

  function getTouchDistance(e) {
    if (e.touches.length < 2) return null;
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  function pointerDown(e) {
    if (e.touches && e.touches.length === 2) {
      lastDistance = getTouchDistance(e);
    } else {
      isDragging = true;
      velocity = 0;
      lastDragX = e.clientX || e.touches[0].clientX;
      lastDragY = e.clientY || e.touches[0].clientY;
    }
  }
  function pointerMove(e) {
    if (e.touches && e.touches.length === 2) {
      const distance = getTouchDistance(e);
      if (lastDistance != null) {
        const delta = distance - lastDistance;
        lastDistance = distance;
        const zoomSensitivity = 0.005;
        zoomFactor += delta * zoomSensitivity;
        zoomFactor = Math.max(1, Math.min(4, zoomFactor));
        zoomVelocity = delta * zoomSensitivity * 0.3;
      }
    } else if (isDragging) {
      const x = e.clientX || e.touches[0].clientX;
      const y = e.clientY || e.touches[0].clientY;
      const dx = x - lastDragX, dy = y - lastDragY;
      lastDragX = x; lastDragY = y;
      cameraAngle -= dx * 0.0015;
      cameraAngle = (cameraAngle + 2 * Math.PI) % (2 * Math.PI);
      velocity = dx * 0.0015;
      if (zoomFactor <= 1.1) verticalVelocity += dy * 0.3;
    }
  }
  function pointerUp(e) {
    isDragging = false;
    lastDistance = null;
    velocity *= 0.9;
    zoomVelocity *= 0.9;
  }
  canvas.addEventListener('touchstart', pointerDown, { passive: false });
  canvas.addEventListener('touchmove', pointerMove, { passive: false });
  canvas.addEventListener('touchend', pointerUp);
  canvas.addEventListener('mousedown', pointerDown);
  canvas.addEventListener('mousemove', pointerMove);
  canvas.addEventListener('mouseup', pointerUp);
})();
</script>
</body>
</html>
